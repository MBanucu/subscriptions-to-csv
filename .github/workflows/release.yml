name: Release

on:
  workflow_run:
    workflows: ["CI"]
    types:
      - completed
    branches:
      - main
  workflow_dispatch:

jobs:
  release:
    runs-on: ubuntu-latest
    outputs:
      release_branch: ${{ steps.create-branch.outputs.branch_name }}
      released: ${{ steps.release.outputs.released }}
      version: ${{ steps.release.outputs.version }}
      changelog: ${{ steps.release.outputs.changelog }}
      has_release_commits: ${{ steps.check-commits.outputs.has_release_commits }}
    permissions:
      contents: write
      issues: write
      pull-requests: write
      id-token: write  # IMPORTANT: this permission is mandatory for trusted publishing

    steps:
    - name: Checkout
      uses: actions/checkout@v6
      with:
        fetch-depth: 0  # Important for semantic-release to analyze all commits

    - name: Check for release-worthy commits
      id: check-commits
      run: |
        # Check if there are conventional commits since last release
        LAST_RELEASE=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
        if [ -z "$LAST_RELEASE" ]; then
          # No releases yet, check all commits
          RELEASE_COMMITS=$(git log --oneline --grep="^feat:\|^fix:\|BREAKING" | wc -l)
        else
          # Check commits since last release
          RELEASE_COMMITS=$(git log "${LAST_RELEASE}..HEAD" --oneline --grep="^feat:\|^fix:\|BREAKING" | wc -l)
        fi

        if [ "$RELEASE_COMMITS" -gt 0 ]; then
          echo "has_release_commits=true" >> $GITHUB_OUTPUT
          echo "Found $RELEASE_COMMITS release-worthy commits"
        else
          echo "has_release_commits=false" >> $GITHUB_OUTPUT
          echo "No release-worthy commits found"
        fi

    - name: Determine next version (Dry Run)
      if: steps.check-commits.outputs.has_release_commits == 'true'
      uses: python-semantic-release/python-semantic-release@v10
      id: release
      with:
        no_operation_mode: true
        github_token: ${{ secrets.GITHUB_TOKEN }}

    - name: Create release branch (if release needed)
      id: create-branch
      if: steps.check-commits.outputs.has_release_commits == 'true' && steps.release.outputs.released == 'true'
      run: |
        BRANCH_NAME="release/${{ steps.release.outputs.tag }}"
        git checkout -b "$BRANCH_NAME"
        echo "branch_name=$BRANCH_NAME" >> $GITHUB_OUTPUT

    - name: Update version and create release (if release branch created)
      if: steps.create-branch.outputs.branch_name != ''
      uses: python-semantic-release/python-semantic-release@v10
      with:
        push: false
        vcs_release: false
        commit: true
        changelog: true
        github_token: ${{ secrets.GITHUB_TOKEN }}

    - name: Push release branch (if created)
      if: steps.create-branch.outputs.branch_name != ''
      env:
        GITHUB_TOKEN: ${{ github.token }}
      run: |
        git push --force origin "${{ steps.create-branch.outputs.branch_name }}"

    - name: Check if PR already exists (if release branch created)
      id: check-pr
      if: steps.create-branch.outputs.branch_name != ''
      env:
        GITHUB_TOKEN: ${{ github.token }}
      run: |
        BRANCH="${{ steps.create-branch.outputs.branch_name }}"
        EXISTING_PR=$(gh pr list --head "$BRANCH" --json number --jq 'length')
        echo "pr_exists=$EXISTING_PR" >> $GITHUB_OUTPUT
        if [ "$EXISTING_PR" -gt 0 ]; then
          PR_NUMBER=$(gh pr list --head "$BRANCH" --json number --jq '.[0].number')
          echo "existing_pr_number=$PR_NUMBER" >> $GITHUB_OUTPUT
        fi

    - name: Close existing PR (if PR exists)
      if: steps.check-pr.outputs.pr_exists != '0'
      env:
        GITHUB_TOKEN: ${{ github.token }}
      run: |
        PR_NUMBER=${{ steps.check-pr.outputs.existing_pr_number }}
        echo "Closing existing PR #$PR_NUMBER to ensure fresh CI triggering..."
        gh pr close $PR_NUMBER --comment "Closed to create fresh PR with proper CI triggering"

    - name: Create pull request (always create fresh PR)
      id: create-pr
      if: steps.create-branch.outputs.branch_name != ''
      env:
        GH_TOKEN: ${{ secrets.GH_TOKEN }}
      run: |
        TITLE="chore(release): ${{ steps.release.outputs.version }}"
        BODY="Automated release ${{ steps.release.outputs.version }}

        ## Changes
        ${{ steps.release.outputs.changelog }}

        ---
        ðŸ¤– This PR was automatically created by the release workflow."

        # Create the PR and capture the URL
        PR_URL=$(echo "$BODY" | gh pr create \
          --title "$TITLE" \
          --body-file - \
          --base main \
          --head "${{ steps.create-branch.outputs.branch_name }}")

        # Extract PR number from URL (format: https://github.com/owner/repo/pull/123)
        PR_NUMBER=$(echo "$PR_URL" | grep -o '[0-9]\+$')

        echo "pr_number=$PR_NUMBER" >> $GITHUB_OUTPUT
        echo "âœ… Release PR #$PR_NUMBER created: $PR_URL"

    - name: Enable auto-merge for release PR
      if: steps.create-branch.outputs.branch_name != ''
      env:
        GITHUB_TOKEN: ${{ github.token }}
      run: |
        PR_NUMBER=${{ steps.create-pr.outputs.pr_number }}

        echo "Enabling auto-merge for PR #$PR_NUMBER"
        gh pr merge $PR_NUMBER --auto --rebase

        echo "ðŸ¤– Auto-merge enabled for release PR #$PR_NUMBER"

    - name: Wait for PR to merge
      if: steps.create-branch.outputs.branch_name != ''
      env:
        GITHUB_TOKEN: ${{ github.token }}
      run: |
        PR_NUMBER=${{ steps.create-pr.outputs.pr_number }}
        echo "Waiting for PR #$PR_NUMBER to be merged..."

        # Wait for checks to be reported (timeout 10s)
        counter=0
        while [ $counter -lt 10 ]; do
          if gh pr checks $PR_NUMBER | grep -q "pass\|fail\|pending"; then
            echo "Checks reported for PR #$PR_NUMBER"
            break
          fi
          echo "Waiting for checks to be reported..."
          sleep 1
          counter=$((counter + 1))
        done

        if [ $counter -eq 10 ]; then
          echo "Error: Checks did not start within 10 seconds for PR #$PR_NUMBER"
          exit 1
        fi

        gh pr checks $PR_NUMBER --watch

        # Check for failing checks
        if gh pr checks $PR_NUMBER | grep -q "fail"; then
          echo "Error: Some checks failed for PR #$PR_NUMBER"
          exit 1
        fi

        # Wait for merge (timeout 10 minutes)
        merge_counter=0
        while [ $merge_counter -lt 600 ]; do
          MERGED_AT=$(gh pr view $PR_NUMBER --json mergedAt --jq .mergedAt)
          if [ "$MERGED_AT" != "" ]; then
            echo "PR #$PR_NUMBER has been merged!"
            break
          fi
          echo "PR #$PR_NUMBER not yet merged, waiting..."
          sleep 1
          merge_counter=$((merge_counter + 1))
        done

        if [ $merge_counter -eq 600 ]; then
          echo "Error: PR #$PR_NUMBER was not merged within 10 minutes"
          exit 1
        fi

  publish:
    needs: release
    if: needs.release.outputs.released == 'true' && needs.release.outputs.has_release_commits == 'true'
    runs-on: ubuntu-latest
    permissions:
      contents: write  # For creating GitHub releases
      id-token: write  # IMPORTANT: this permission is mandatory for trusted publishing

    steps:
    - name: Checkout main branch
      uses: actions/checkout@v6
      with:
        fetch-depth: 0

    - name: Pull latest changes
      run: git pull origin main

    - name: Set up Python
      uses: actions/setup-python@v6
      with:
        python-version: '3.x'

    - name: Install build dependencies
      run: |
        python -m pip install --upgrade pip
        pip install build

    - name: Build package
      run: python -m build

    - name: Publish to PyPI
      uses: pypa/gh-action-pypi-publish@release/v1
      with:
        print-hash: true

    - name: Create GitHub release
      env:
        GITHUB_TOKEN: ${{ github.token }}
      run: |
        echo "Creating GitHub release v${{ needs.release.outputs.version }}..."

        # Create the release with generated notes
        gh release create v${{ needs.release.outputs.version }} \
          --title "Release v${{ needs.release.outputs.version }}" \
          --notes "${{ needs.release.outputs.changelog }}"

        echo "âœ… GitHub release created successfully"


